//! Type definitions for ESPHome entities

use crate::proto::api::{
    BinarySensorStateResponse, CoverStateResponse, FanSpeed, FanStateResponse, LightStateResponse,
    SensorStateResponse, SwitchStateResponse, TextSensorStateResponse,
};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::time::{Duration, SystemTime};

/// Represents the current authentication state
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AuthState {
    /// Not authenticated
    NotAuthenticated,
    /// Authenticated with a password
    Authenticated,
    /// No authentication required
    NoAuth,
    /// Authentication in progress
    InProgress,
}

/// Represents a device's connection information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceAddress {
    /// The host address (IP or hostname)
    pub host: String,
    /// The port
    pub port: u16,
    /// Optional password for authentication
    pub password: Option<String>,
    /// Last seen timestamp
    #[serde(skip)]
    pub last_seen: Option<SystemTime>,
    /// Connection timeout
    #[serde(skip)]
    pub timeout: Duration,
}

impl Default for DeviceAddress {
    fn default() -> Self {
        Self {
            host: "localhost".to_string(),
            port: 6053, // Default ESPHome API port
            password: None,
            last_seen: None,
            timeout: Duration::from_secs(5),
        }
    }
}

impl From<SocketAddr> for DeviceAddress {
    fn from(addr: SocketAddr) -> Self {
        Self {
            host: addr.ip().to_string(),
            port: addr.port(),
            password: None,
            last_seen: Some(SystemTime::now()),
            timeout: Duration::from_secs(5),
        }
    }
}

/// State of a binary sensor
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BinarySensorState {
    /// The ID of the binary sensor
    pub id: String,
    /// The current state (on/off)
    pub state: bool,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<BinarySensorStateResponse> for BinarySensorState {
    fn from(response: BinarySensorStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            state: response.state,
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a switch
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwitchState {
    /// The ID of the switch
    pub id: String,
    /// The current state (on/off)
    pub state: bool,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<SwitchStateResponse> for SwitchState {
    fn from(response: SwitchStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            state: response.state,
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a sensor
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SensorState {
    /// The ID of the sensor
    pub id: String,
    /// The current value
    pub value: f32,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<SensorStateResponse> for SensorState {
    fn from(response: SensorStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            value: response.state,
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a text sensor
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextSensorState {
    /// The ID of the text sensor
    pub id: String,
    /// The current value
    pub value: String,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<TextSensorStateResponse> for TextSensorState {
    fn from(response: TextSensorStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            value: response.state,
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a light
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LightState {
    /// The ID of the light
    pub id: String,
    /// The current state (on/off)
    pub state: bool,
    /// The current brightness (0-255)
    pub brightness: Option<u32>,
    /// The current RGB color
    pub rgb: Option<(u32, u32, u32)>,
    /// The current color temperature
    pub color_temperature: Option<f32>,
    /// The current effect
    pub effect: Option<String>,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<LightStateResponse> for LightState {
    fn from(response: LightStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            state: response.state,
            brightness: if response.brightness > 0.0 {
                Some((response.brightness * 255.0) as u32)
            } else {
                None
            },
            rgb: if response.red > 0.0 || response.green > 0.0 || response.blue > 0.0 {
                Some((
                    (response.red * 255.0) as u32,
                    (response.green * 255.0) as u32,
                    (response.blue * 255.0) as u32,
                ))
            } else {
                None
            },
            color_temperature: if response.color_temperature > 0.0 {
                Some(response.color_temperature)
            } else {
                None
            },
            effect: if !response.effect.is_empty() {
                Some(response.effect)
            } else {
                None
            },
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a fan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FanState {
    /// The ID of the fan
    pub id: String,
    /// The current state (on/off)
    pub state: bool,
    /// The current speed (0-100)
    pub speed: Option<u32>,
    /// The oscillation state
    pub oscillating: Option<bool>,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<FanStateResponse> for FanState {
    fn from(response: FanStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            state: response.state,
            speed: match response.speed() {
                FanSpeed::Low => Some(25),
                FanSpeed::Medium => Some(50),
                FanSpeed::High => Some(75),
            },
            oscillating: Some(response.oscillating),
            last_updated: SystemTime::now(),
        }
    }
}

/// State of a cover
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoverState {
    /// The ID of the cover
    pub id: String,
    /// The current position (0-100)
    pub position: Option<u32>,
    /// The current tilt (0-100)
    pub tilt: Option<u32>,
    /// The current operation
    pub current_operation: u32,
    /// When the state was last updated
    pub last_updated: SystemTime,
}

impl From<CoverStateResponse> for CoverState {
    fn from(response: CoverStateResponse) -> Self {
        Self {
            id: response.key.to_string(),
            position: if response.position > 0.0 {
                Some((response.position * 100.0) as u32)
            } else {
                None
            },
            tilt: if response.tilt > 0.0 {
                Some((response.tilt * 100.0) as u32)
            } else {
                None
            },
            current_operation: response.current_operation as u32,
            last_updated: SystemTime::now(),
        }
    }
}
