use esphome::connection::ESPHomeConnection;
use esphome::error::Result;
use std::time::Duration;
use tokio::time::sleep;

// Import the shared test utilities
mod utils;

/// Test basic functionality of the ESPHomeConnection
///
/// This test verifies:
/// 1. Creating a new connection
/// 2. Sending a hello request
/// 3. Establishing an authenticated connection
/// 4. Getting device information
/// 5. Sending ping requests
/// 6. Graceful disconnection
#[tokio::test]
async fn test_basic_connection() -> Result<()> {
    println!("=== STARTING BASIC CONNECTION TEST ===");

    // Initialize logging
    utils::init_logging();
    println!("Logging initialized");

    // Get device info from environment or defaults
    let (host, port, password) = match utils::get_real_device_info() {
        Some(info) => {
            println!("Got device info: {}:{}", info.0, info.1);
            info
        }
        None => {
            println!("Skipping basic connection test (no device info available)");
            return Ok(());
        }
    };

    let address = format!("{}:{}", host, port);
    println!("Starting basic connection test with device at {}", address);

    // Step 1: Create a new connection
    let mut connection = ESPHomeConnection::new(address.clone(), password.clone()).await?;
    println!("Connection object created successfully");

    // Step 2: Send a hello request
    let hello_response = connection.hello().await?;
    println!("Hello response received:");
    println!("  Server Info: {}", hello_response.server_info);
    println!(
        "  API Version: {}.{}",
        hello_response.api_version_major, hello_response.api_version_minor
    );

    // Step 3: Establish an authenticated connection
    let connect_response = connection.connect().await?;
    println!("Connection established successfully");

    // Step 4: Get device information
    let device_info = connection.device_info().await?;
    println!("Device information received:");
    println!("  Name: {}", device_info.name);
    println!("  MAC Address: {}", device_info.mac_address);
    println!("  ESPHome Version: {}", device_info.esphome_version);
    println!("  Compilation Time: {}", device_info.compilation_time);
    println!("  Model: {}", device_info.model);
    println!("  Has Deep Sleep: {}", device_info.has_deep_sleep);
    println!("  Project Name: {}", device_info.project_name);
    println!("  Project Version: {}", device_info.project_version);

    // Step 5: Send a ping request to verify connection is alive
    let ping_response = connection.ping().await?;
    println!("Ping successful");

    // Send multiple pings with delays to ensure connection stability
    for i in 1..=3 {
        println!("Sending ping {}/3...", i);
        sleep(Duration::from_secs(1)).await;
        let ping_response = connection.ping().await?;
        println!("Ping {} successful", i);
    }

    // Step 6: Gracefully disconnect
    let disconnect_response = connection.disconnect().await?;
    println!("Disconnected successfully");

    // Verify disconnection by trying to ping (should fail)
    match connection.ping().await {
        Ok(_) => {
            println!(
                "WARNING: Ping after disconnect succeeded, connection may not be fully closed"
            );
        }
        Err(e) => {
            println!("Ping after disconnect failed as expected: {}", e);
        }
    }

    println!("=== BASIC CONNECTION TEST COMPLETED SUCCESSFULLY ===");
    Ok(())
}

/// Test the connection builder pattern
#[tokio::test]
async fn test_connection_builder() -> Result<()> {
    println!("=== STARTING CONNECTION BUILDER TEST ===");

    // Initialize logging
    utils::init_logging();
    println!("Logging initialized");

    // Get device info from environment or defaults
    let (host, port, password) = match utils::get_real_device_info() {
        Some(info) => {
            println!("Got device info: {}:{}", info.0, info.1);
            info
        }
        None => {
            println!("Skipping connection builder test (no device info available)");
            return Ok(());
        }
    };

    let address = format!("{}:{}", host, port);
    println!(
        "Starting connection builder test with device at {}",
        address
    );

    // Test the builder pattern
    use esphome::connection::ESPHomeConnectionBuilder;

    let connection = ESPHomeConnectionBuilder::new(address.clone())
        .password(password.unwrap_or_default())
        .build()
        .await?;

    println!("Connection built successfully using builder pattern");

    // Test the connect convenience method
    let mut connection = ESPHomeConnectionBuilder::new(address.clone())
        .password(password.unwrap_or_default())
        .connect()
        .await?;

    println!("Connection established successfully using builder pattern");

    // Verify connection is working by sending a ping
    let ping_response = connection.ping().await?;
    println!("Ping successful");

    // Disconnect
    connection.disconnect().await?;
    println!("Disconnected successfully");

    println!("=== CONNECTION BUILDER TEST COMPLETED SUCCESSFULLY ===");
    Ok(())
}

/// Test subscription to state updates
#[tokio::test]
async fn test_state_subscription() -> Result<()> {
    println!("=== STARTING STATE SUBSCRIPTION TEST ===");

    // Initialize logging
    utils::init_logging();
    println!("Logging initialized");

    // Get device info from environment or defaults
    let (host, port, password) = match utils::get_real_device_info() {
        Some(info) => {
            println!("Got device info: {}:{}", info.0, info.1);
            info
        }
        None => {
            println!("Skipping state subscription test (no device info available)");
            return Ok(());
        }
    };

    let address = format!("{}:{}", host, port);
    println!(
        "Starting state subscription test with device at {}",
        address
    );

    // Create and connect
    let mut connection = ESPHomeConnection::new(address.clone(), password).await?;
    connection.hello().await?;
    connection.connect().await?;
    println!("Connection established successfully");

    // Subscribe to state updates
    connection.subscribe_states().await?;
    println!("Subscribed to state updates successfully");

    // Keep the connection open for a short time to receive some state updates
    println!("Waiting for state updates for 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    // Subscribe to logs
    connection.subscribe_logs(None).await?;
    println!("Subscribed to logs successfully");

    // Wait a bit longer to receive some log messages
    println!("Waiting for log messages for 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    // Disconnect
    connection.disconnect().await?;
    println!("Disconnected successfully");

    println!("=== STATE SUBSCRIPTION TEST COMPLETED SUCCESSFULLY ===");
    Ok(())
}

/// Test error handling for invalid connection parameters
#[tokio::test]
async fn test_error_handling() -> Result<()> {
    println!("=== STARTING ERROR HANDLING TEST ===");

    // Initialize logging
    utils::init_logging();
    println!("Logging initialized");

    // Test with invalid address
    let invalid_address = "255.255.255.255:6053"; // Broadcast address, should not respond
    println!("Testing connection to invalid address: {}", invalid_address);

    match ESPHomeConnection::new(invalid_address, None).await {
        Ok(_) => {
            println!("WARNING: Connection to invalid address succeeded unexpectedly");
        }
        Err(e) => {
            println!("Connection to invalid address failed as expected: {}", e);
        }
    }

    // Test with valid address but invalid password
    let (host, port, _) = match utils::get_real_device_info() {
        Some(info) => info,
        None => {
            println!("Skipping invalid password test (no device info available)");
            return Ok(());
        }
    };

    let address = format!("{}:{}", host, port);
    println!(
        "Testing connection to valid address with invalid password: {}",
        address
    );

    // Create connection
    let mut connection = match ESPHomeConnection::new(address.clone(), None).await {
        Ok(conn) => conn,
        Err(e) => {
            println!("Failed to create connection object: {}", e);
            return Ok(());
        }
    };

    // Send hello
    match connection.hello().await {
        Ok(_) => {
            println!("Hello succeeded (expected, as it doesn't require authentication)");
        }
        Err(e) => {
            println!("Hello failed: {}", e);
            return Ok(());
        }
    }

    // Try to connect with invalid password
    let invalid_password = Some("this_is_definitely_not_the_password".to_string());

    // Reset the connection with the invalid password
    let mut connection = match ESPHomeConnection::new(address.clone(), invalid_password).await {
        Ok(conn) => conn,
        Err(e) => {
            println!("Failed to create connection object: {}", e);
            return Ok(());
        }
    };

    // Send hello
    match connection.hello().await {
        Ok(_) => println!("Hello succeeded"),
        Err(e) => {
            println!("Hello failed: {}", e);
            return Ok(());
        }
    }

    // Try to connect with invalid password
    match connection.connect().await {
        Ok(_) => {
            println!("WARNING: Connect with invalid password succeeded unexpectedly");
        }
        Err(e) => {
            println!("Connect with invalid password failed as expected: {}", e);
        }
    }

    println!("=== ERROR HANDLING TEST COMPLETED SUCCESSFULLY ===");
    Ok(())
}
