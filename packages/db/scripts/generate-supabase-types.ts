#!/usr/bin/env tsx

import fs from 'node:fs/promises';
import { join } from 'node:path';
import { $ } from 'zx';

const TEMP_FILE = '.temp.types.ts';
const FINAL_FILE = join('src', 'supabase', 'types.generated.ts');

async function main() {
  try {
    // Use database URL if project ID is not available
    const projectId = process.env.SUPABASE_PROJECT_ID;
    const dbUrl = process.env.POSTGRES_URL || process.env.DATABASE_URL;

    // Generate types
    if (projectId?.trim()) {
      await $`npx supabase gen types typescript --project-id ${projectId} --schema public > ${TEMP_FILE}`;
    } else if (dbUrl) {
      await $`npx supabase gen types typescript --db-url ${dbUrl} --schema public > ${TEMP_FILE}`;
    } else {
      throw new Error('Either SUPABASE_PROJECT_ID or POSTGRES_URL must be set');
    }

    // Read the generated types
    const generatedTypes = await fs.readFile(TEMP_FILE, 'utf-8');

    // Create the final content with header
    const finalContent = [
      '// !!!GENERATED FILE, DO NOT EDIT!!!',
      '// This file is auto-generated by supabase in scripts/generate-types.ts',
      '// Schema: public',
      `// Generated at: ${new Date().toISOString()}`,
      '',
      generatedTypes,
    ].join('\n');

    // Write to final location
    await fs.writeFile(FINAL_FILE, finalContent);
  } finally {
    // Cleanup temp file
    try {
      await fs.rm(TEMP_FILE, { force: true });
    } catch (error) {
      console.error('Error cleaning up temp file:', error);
    }
  }
}

main().catch((error) => {
  console.error('Error generating types:', error);
  process.exit(1);
});
